#now wait for a second and think
#user objects are now created from the backend using a lambda function on post confirmation
#should only be queried by the owner
type User@model
@auth(rules:[{allow:owner,operations:[create,update,delete]}])#allow people to read
@key(name:"byUser",fields:["userId"])
{
  id:ID
  userId:ID!
  username:String!
  #protect the conversations attribute from being queried
  conversations:[DirectMessageEditor] @connection(keyName:"byUser",fields:["userId"])
  #@auth(rules:[{allow:owner,operations:[create,update,read,delete]}])
}

#1 editor per number of editors in conversation
#min 2 objects
#now we are connected to the user object
type DirectMessageEditor@model
@key(name:"byUser",fields:["userId"])
{
  id:ID
  conversationId:ID!
  userId:ID!
  #this is a circular reference infinite recursion user -> conversation->user ->...
  #user:[User] @connection(keyName:"byUser",fields:["userId"])
}

#to write to a conversation a user must be a part of that conversation
#many users
type DirectMessageChat@model{
  id:ID
  conversationId:ID!
  messages:[Message] @connection(keyName:"byConversation",fields:["conversationId"])
}

#messages have a an author recipient and a particular conversation they belong to
type Message@model
@key(name:"byConversation",fields:["conversationId"])
{
  id:ID
  authorId:ID!
  recipientId:ID! #use this id to create a subscription exclusive to only the id of the signed in user
  conversationId:ID!
  content:String
  createdAt:String
  isSnap:Boolean!#
  bucket: String
  region: String
  key: String
  unread: Boolean#
}

type Subscription{
  onCreateMessageForRecipient(recipientId:ID!): Message
  @aws_subscribe(mutations:["createMessage"])

  onCreateFriendRequestForRecipient(recipientId:ID!): FriendRequest
  @aws_subscribe(mutations:["createFriendRequest"])

  onCreateFriendRequestResponseForSelf(requestSenderId:ID!): FriendRequestResponse
  @aws_subscribe(mutations:["onAcceptFriendRequest","onDeclineFriendRequest"])
}

type Query{
  onDeleteFriendRequest(id:ID!): String!
}

type Mutation{
  onAcceptFriendRequest(requestSenderId:ID!) : FriendRequestResponse #create backend stuff
  onDeclineFriendRequest(requestSenderId:ID!) : FriendRequestResponse #don't create backend stuff
}

type FriendRequest @model
@key(name:"byRecipient",fields:["recipientId"])
{ 
    id:ID
    authorId:ID!
    authorUsername:String!#so we don't then have to query for it
    recipientId:ID!
}

type FriendRequestResponse @model
@key(name:"byRequestSender",fields:["requestSenderId"]){
    id:ID
    #when a response is accepted
    #delete the friendRequestObject
    #honestly this doesn't need to be an object does it?
    #for rejections it does
    #the id who sent this
    requestSenderId:ID!#id of the person who sent the friend request
    accepted:Boolean!
    conversationId:ID 
    #option conversation id needs to be filled in by resolver
    #if accepted field is true
    #a conversation object needs to be created
    #and 2 editors need to be created
    #each user must get their own editor and 
    #each user needs to sub to an editor
    #then each user can append to the conversation
}

#type Todo@model
#owner is specified explicitly on every object
#anyone can read only owner can create, update or delete
#@auth(rules:[{allow:owner,operations:[create,update,delete]}])
#@key(name:"byUser",fields:["userId"]){
#  id:ID
#  userId:ID! #the owner of the friendlist
  #owner:String <-this is autogenerated if not specified
  #try creating a field that only the owner can read
  #need to be explicit with operations since transformer will mark them undefined
#  privateField:String @auth(rules:[{allow:owner,operations:[create,update,read,delete]}])#only owner can do anything with this field
  #to test this try and grab this from a post that i am not an owner of
#}
#test field level authorization without type level authorization
#field level authorization automatically adds owner field within type 
#type Event@model
#owner is specified explicitly on every object
#anyone can read only owner can create, update or delete
#@key(name:"byUser",fields:["userId"]){
#  id:ID
#  userId:ID! #the owner of the friendlist
  #owner:String <-this is autogenerated if not specified
  #try creating a field that only the owner can read
  #need to be explicit with operations since transformer will mark them undefined
#  privateField:String @auth(rules:[{allow:owner,operations:[create,update,read,delete]}])#only owner can do anything with this field
  #to test this try and grab this from a post that i am not an owner of
#}